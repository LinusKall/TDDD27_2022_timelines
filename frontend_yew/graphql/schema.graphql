input CreateTimelineInput {
  title: String!
  public: Boolean!
}

input CreateUserInput {
  username: String!
  email: String!
  hashedPassword: String!
}

# Implement the DateTime<Utc> scalar
#
# The input/output is a string in RFC3339 format.
scalar DateTime

type DateTimeWrapper {
  inner: DateTime!
}

type DeleteTimelineResult {
  success: Boolean!
  rowsAffected: Int!
}

type DeleteUserResult {
  success: Boolean!
  rowsAffected: Int!
}

type Mutation {
  createUser(input: CreateUserInput!): User!
  deleteUser(id: Int!): DeleteUserResult!
  createTimeline(input: CreateTimelineInput!): Timeline!
  deleteTimeline(id: Int!): DeleteTimelineResult!
}

type NestedEvent {
  id: Int!
  timelineId: Int!
  title: String!
  body: String
  startTime: DateTimeWrapper!
  endTime: DateTimeWrapper!
}

type NestedSubTask {
  id: Int!
  taskId: Int!
  title: String!
  done: Boolean!
}

type NestedTask {
  id: Int!
  timelineId: Int!
  title: String!
  body: String
  done: Boolean!
  endTime: DateTimeWrapper!
  subTasks: [NestedSubTask!]!
}

type NestedTimeline {
  id: Int!
  title: String!
  color: String!
  events: [NestedEvent!]!
  tasks: [NestedTask!]!
}

type Query {
  getUsers: [User!]!
  getUserById(id: Int!): User
  getUserId(username: String!, password: String!): Int
  getUserData(id: Int!, hashedPassword: String!): UserData!
  getTimelines: [Timeline!]!
  getTimelineById(id: Int!): Timeline
}

type Subscription {
  interval(n: Int! = 1): Int!
}

type Timeline {
  id: Int!
  title: String!
  public: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type User {
  id: Int!
  username: String!
  email: String!
  hashedPassword: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserData {
  id: Int!
  timelines: [NestedTimeline!]!
}
